# Individual Project Data to Model Pipeline (IPDMP)

## Description

The Individual Project Data to Model Pipeline (IPDMP) is a Python-based project designed to automate the workflow of generating labeled training data from satellite imagery and using this data to train and deploy a machine learning model for water body identification.

The pipeline consists of several key components:

1.  **Navigable Automated Labelling Interface for Regions of Attention (NALIRA)** (`NALIRA.py`): Processes Sentinel-2 satellite imagery, calculates the Normalized Difference Water Index (NDWI), performs cloud masking, and provides an interactive graphical user interface (GUI) for manually labeling regions of interest (reservoirs, water bodies, land, and sea). It generates the initial labeled coordinates and segments the image data into smaller classified images (mini-chunks) used for training.
2.  **Keras Reservoir Identification Sequential Platform (KRISP) - Trainer** (`KRISP_trainer.py`, `epoch_pathfinder.py`): Uses the segmented image data generated by NALIRA to train a Keras Sequential convolutional neural network (CNN). It includes a helper script (`epoch_pathfinder.py`) to determine the optimal number of training epochs to prevent overfitting.
3.  **KRISP - Predictor (KRISP-Y)** (`KRISP-Y.py`, `KRISP.py`): Loads the trained KRISP model and deploys it to classify mini-chunks across an entire satellite image tile, generating a prediction file. An automated version, `KRISP-Y_auto.py`, can run predictions with multiple models sequentially.
4.  **KRISP External Technical Testing Environment (KRISPETTE)** (`KRISPETTE.py`): A testing environment for KRISP to evaluate model performance by generating a confusion matrix and calculating accuracy, precision, recall, specificity, and F1-score.
5.  **Supporting Modules**: Includes scripts for data handling (`data_handling.py`), image processing (`image_handling.py`), user interfacing elements (`user_interfacing.py`), and miscellaneous utilities (`misc.py`).

The overall goal is to provide a streamlined process from raw satellite data to a trained model capable of identifying water features.

## Features

* **End-to-End Pipeline:** Covers data preparation, labeling, training, and prediction.
* **Sentinel-2 Focused:** Optimized for processing Sentinel-2 `.SAFE` format imagery.
* **Water Index Calculation:** Implements NDWI.
* **Cloud Masking:** Uses OmniCloudMask with Sentinel-2 bands to mask clouds.
* **Interactive Labeling GUI:** Tkinter-based interface (`NALIRA.py`) for drawing bounding boxes around features of interest.
* **Automated Data Segmentation:** `NALIRA.py` automatically crops and saves labeled image examples into class-specific folders.
* **CNN Model Training:** `KRISP_trainer.py` trains a sequential CNN model using TensorFlow/Keras.
* **Epoch Optimization:** `epoch_pathfinder.py` helps visualize training/validation curves to select an appropriate number of epochs.
* **Batch Prediction:** `KRISP-Y.py` efficiently processes large images in batches for prediction.
* **Performance Evaluation**: `KRISPETTE.py` provides a testing environment to evaluate the model's performance.
* **Modular Code:** Organized into distinct Python scripts for different functionalities.

## Installation

1.  **Clone the repository:**
    ```bash
    git clone [https://github.com/nicoarrroyo/ipdmp.git](https://github.com/nicoarrroyo/ipdmp.git)
    cd IPDMP
    ```

2.  **Install Required Libraries:**
    This project requires Python (tested with 3.x) and several libraries. You can install them using pip:
    ```bash
    pip install numpy matplotlib Pillow tensorflow pandas tqdm scikit-learn jupyter omnicloudmask geopandas fiona rasterio
    ```
    * `numpy`: For numerical operations and array handling.
    * `matplotlib`: For plotting graphs.
    * `Pillow`: For image manipulation.
    * `tensorflow`: The core machine learning library.
    * `pandas`: Used for results handling.
    * `tqdm`: For progress bars.
    * `tkinter`: Usually included with Python standard library, used for the GUI in `NALIRA.py`.
    * `scikit-learn`: For performance metrics.
    * `jupyter`: For running notebooks.
    * `omnicloudmask`: For cloud masking.
    * `geopandas`: For working with geospatial data.
    * `fiona`: For reading and writing geographic data files.
    * `rasterio`: For reading and writing raster datasets.

## Usage Instructions

To run the entire pipeline, follow these steps sequentially.

**Assumptions:**

* You have downloaded the IPDMP code.
* You have downloaded a Sentinel-2 satellite image tile in `.SAFE` format.

**1. Setup File Structure**

* **Extract Code and Image:** Extract the downloaded code and satellite image to a known location.
* **Create `training data` Folder:** Inside the extracted image folder, create a new folder named `training data`.
* **Move `responses` File:** Move the `responses_5000_chunks.csv` file into the newly created `training data` folder.

**2. Training Data Generation (NALIRA)**

* **Configure and Run `NALIRA.py`:**
    * Open `NALIRA.py` and modify the `HOME` variable to your project's home directory.
    * Execute the script: `python NALIRA.py`
    * The script will process the satellite bands and calculate water indices.
    * A Tkinter window will appear for data labeling.
    * After labeling, NALIRA will automatically segment the images and save them as PNGs in the appropriate class folders.

**3. Model Training (KRISP Trainer & Epoch Pathfinder)**

* **Determine Optimal Epochs (`epoch_pathfinder.py`):**
    * Open `epoch_pathfinder.py` and modify the `BASE_PROJECT_DIR` variable.
    * Run the script: `python epoch_pathfinder.py`
    * Examine the plots to choose the optimal number of epochs.
* **Train the Final Model (`KRISP_trainer.py`):**
    * Open `KRISP_trainer.py` and modify the `BASE_PROJECT_DIR` variable.
    * Set the `EPOCHS` variable to the optimal number you determined.
    * Set `SAVE_MODEL = True`.
    * Run the script: `python KRISP_trainer.py`

**4. Model Deployment/Prediction (KRISP-Y)**

* **Configure and Run `KRISP-Y.py`:**
    * Open `KRISP-Y.py` and modify the `HOME` and `folder` variables.
    * Set the `model_epochs` variable to the number of epochs used for training.
    * Execute the script: `python KRISP-Y.py`
    * The script will load the trained model, run predictions, and save the results to a CSV file.

**5. Accuracy Assessment (KRISPETTE)**

* **Configure and Run `KRISPETTE.py`:**
    * Open the script and modify the `os.chdir(...)` path to your Sentinel-2 image folder.
    * Ensure the filenames for `open()` match your responses and predictions CSV files.
    * Execute the script: `python KRISPETTE.py`
    * It will calculate and print performance metrics.

## Code Structure

* `NALIRA.py`: Main script for data generation and labeling GUI.
* `KRISP_trainer.py`: Trains the Keras CNN model.
* `epoch_pathfinder.py`: Helps determine the optimal number of training epochs.
* `KRISP-Y.py`: Main script for running predictions on full tiles.
* `KRISP-Y_auto.py`: Automated version of `KRISP-Y.py` for running predictions with multiple models.
* `KRISP.py`: Core prediction logic.
* `KRISPETTE.py`: Testing environment for `KRISP`.
* `data_handling.py`: Utility functions for data manipulation.
* `image_handling.py`: Functions for image processing.
* `user_interfacing.py`: GUI and user interaction functions.
* `misc.py`: Miscellaneous helper functions.
* `responses_..._chunks.csv`: (Input/Output) Stores the user-labeled data from NALIRA.
* `P_..._....csv`: (Output) Stores the model predictions from KRISP-Y.
* `saved_models/`: (Output Dir) Folder where trained models are saved.
* `Sentinel 2/<image_folder>/training data/`: (Output Dir) Contains segmented training images.
* `Sentinel 2/<image_folder>/test data/`: (Output Dir) Contains temporary mini-chunk images for prediction.

## Contributing

1.  Fork the repository.
2.  Create a new branch (`git checkout -b feature/YourFeature`).
3.  Make your changes and commit them (`git commit -m 'Add some feature'`).
4.  Push your changes to your fork (`git push origin feature/YourFeature`).
5.  Submit a pull request.

## Contact

* Nicolas Arroyo, nicolas.renato.arroyo@gmail.com, he/him
